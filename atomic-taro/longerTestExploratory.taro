{"atomicTaroViewState":{"variants":[{"variants":{"currentVersion":{"title":"V1","text":"#sort by: if I have catch blocks of size n + kind, how many catch blocks that are of length N and do kind\n# are there\ndef sortByQuestion(statement_N, kind_N, blk):\n    question = [0,0] #matches, doesn't\n    cs = csv.reader(StringIO.StringIO(blk), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    matches = None\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if (kind == \"TRY\" or kind == \"END_TRY\") and len(count)==0:\n            continue\n        if kind == \"CATCH\":\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            if len(count) == 0: #not nested\n                continue\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n            if not matches:\n                question[0] += 1\n                matches = False\n            if len(count) == 0:\n                continue\n        #---if an expression, compare by the full string because we don't\n        #---know what it is\n        elif kind == \"EXPRESSION\":\n            kind = parseExpression(label[1])\n        elif kind == \"THROW\" and prev is not None and prev == \"TRY\" :\n            kind = \"tryTHROW\"\n        #---a lot of these are IF-BLOCK, which mean one thing, don't re-add\n        elif kind == \"BLOCK\" and prev is not None and prev == \"IF\" :\n            prev = \"BLOCK\"\n            continue\n        #---parsing error, probably part of an expression\n        elif not kind.isalpha():\n            continue\n        #---add to dictionary by statement count\n        #print str(statement_count) +\" v \"+str(statement_N)+ \" k \"+kind\n        if (kind == kind_N or statement_count==0):\n            if(matches is None):\n                question[1] += 1\n                matches = True\n        else:#matches is true\n            matches = False\n        prev = kind #save to keep track of sequenced blocks\n    return question\n\n#parses description of try/catch block into csv components, and then counts\n#the number of instances of each component, eg. RETURN or THROW\ndef countBlocks(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            if statement_count == 0:\n                blocks[0][\"EmptyCatch\"] += 1\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        #---if an expression, parse out kind like printStackTrace\n        elif kind == \"EXPRESSION\":\n            kind = parseExpression(label[1])\n    \t#---TOP level try, nothing before it\n        elif kind == \"TRY\" and prev is None:\n            statement_count = -2\n        elif kind == \"THROW\" and prev is not None and prev == \"TRY\" :\n            kind = \"tryTHROW\"\n        #---a lot of these are IF-BLOCK, which mean one thing, don't re-add\n        elif kind == \"BLOCK\" and prev is not None and prev == \"IF\" :\n            prev = \"BLOCK\"\n            continue\n        #---parsing error, probably part of an expression\n        elif kind != \"END_TRY\" and not kind.isalpha():\n            continue\n        #---add to dictionary by statement count\n        if statement_count not in blocks:\n            blocks[statement_count] = {}\n        if kind in blocks[statement_count]:\n             blocks[statement_count][kind] += 1\n        else:\n             blocks[statement_count][kind] = 1\n        prev = kind #save to keep track of sequenced blocks\n\ndef countTryCatchOnly(results, desc):\n    #results includes end try and end catch for debugging (sanity checking)\n    cs = csv.reader(StringIO.StringIO(desc), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) > 0:\n                results[\"Nested Catch\"] += 1\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            results[\"Catch\"] += 1\n        elif kind == \"END_CATCH\":\n            results[\"Statement Count\"] += statement_count\n            statement_count = count.pop()\n            results[\"End Catch\"] += 1\n        elif kind == \"TRY\":\n            results[\"Try\"] += 1\n        elif kind == \"END_TRY\":\n            results[\"End Try\"] +=1\n    return results\n\n\n\ndef whatDidYouThrow(tDict):\n\tcs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n\tdesc = list(cs)[0]\n\tcount = [] #for nested blocks, we need a stack of statement_count\n\tstatement_count = -1\n\tprev = None\n\tcatchvar = []\n\tfor blk in desc:\n\t\tlabel = [x.strip() for x in blk.split(\":\")]\n\t\tkind = label[0]\n\t\tthrow = None\n\t\t#---count # of statements in each catch block in in CATCH : #N\n\t\tif kind == \"CATCH\":\n\t\t    if len(count) == 0: #not nested\n\t\t        kind = \"TOTAL\" #top level Catch, to distinguish nested\n\t\t    count.append(statement_count+0) #old one in case nested\n\t\t    statement_count = int(label[1])\n\t\t\t#catchvar[]\n\t\tif kind == \"END_CATCH\":\n\t\t    statement_count = count.pop()\n\t\tif kind == \"THROW\":\n\t\t\tif prev != \"TRY\":\n\t\t\t\tthrow = label[1]\n\t\t\t\tif throw == '\\\"NEW':\n\t\t\t\t\tthrow = label[2]\n\t\t\t\telif throw == '\\\"VARACCES':\n\t\t\t\t\tprint \"d\"\n\n\t\t\t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n\t\t#---add to dictionary by statement count\n\t\tif throw is not None:\n\t\t    if statement_count not in blocks:\n\t\t        blocks[statement_count] = {}\n\t\t    if throw in blocks[statement_count]:\n\t\t         blocks[statement_count][throw] += 1\n\t\t    else:\n\t\t         blocks[statement_count][throw] = 1\n\t\tprev = kind #save to keep track of sequenced blocks\n\ndef whatDidYouCatch(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        catch = None\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            tocatch = label[2][1:-1].split(\"|\")\n            catch = []\n            for c in tocatch:\n                catch.append(c)\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        \t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n        #---add to dictionary by statement count\n        if catch is not None:\n            if statement_count not in blocks:\n                blocks[statement_count] = {}\n            for c in catch:\n            \tif c in blocks[statement_count]:\n            \t     blocks[statement_count][c] += 1\n            \telse:\n            \t     blocks[statement_count][c] = 1\n        prev = kind #save to keep track of sequenced blocks\n\ndef whatDidYouCatch(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        catch = None\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            tocatch = label[2][1:-1].split(\"|\")\n            catch = []\n            for c in tocatch:\n                catch.append(c)\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        \t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n        #---add to dictionary by statement count\n        if catch is not None:\n            if statement_count not in blocks:\n                blocks[statement_count] = {}\n            for c in catch:\n            \tif c in blocks[statement_count]:\n            \t     blocks[statement_count][c] += 1\n            \telse:\n            \t     blocks[statement_count][c] = 1\n        prev = kind #save to keep track of sequenced blocks\n\n\ndef parseExpression(desc):\n    c_EXPRESSION[\"TOTAL\"] += 1\n    m = parse(\"{method}({rest}\", desc[\"c_code\"])\n    if(m is None):\n        m = parse(\"{method}.{rest}\", desc[\"c_code\"])\n    if(m is None):\n        m = \"\"\n        #print \"DID NOT PARSE |\"+desc[\"c_code\"]+\"|\"\n    else:\n        methd = m[\"method\"]\n        if methd.find(\"printStackTrace\") != -1:\n            c_EXPRESSION[\"stackTrace\"] += 1\n        elif methd.startswith(\"System.out.println\") or methd.startswith(\"System.err.println\"):\n            c_EXPRESSION[\"println\"] +=1\n        elif methd.find(\"print\") != -1:\n            c_EXPRESSION[\"print(general)\"] +=1\n        elif methd.lower().startswith(\"log\") or methd.lower().find(\".log\") != -1:\n            c_EXPRESSION[\"log\"] +=1\n            #print desc[\"c_code\"]\n        elif methd.lower().startswith(\"assert\"):\n            c_EXPRESSION[\"Assert\"] +=1\n        else:\n            c_EXPRESSION[\"unaccounted\"] += 1\n            lines.append(methd)\n","date":"08/03/2016 10:29am"},"versions":[{"title":"","text":"#sort by: if I have catch blocks of size n + kind, how many catch blocks that are of length N and do kind\n# are there\ndef sortByQuestion(statement_N, kind_N, blk):\n    question = [0,0] #matches, doesn't\n    cs = csv.reader(StringIO.StringIO(blk), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    matches = None\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if (kind == \"TRY\" or kind == \"END_TRY\") and len(count)==0:\n            continue\n        if kind == \"CATCH\":\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            if len(count) == 0: #not nested\n                continue\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n            if not matches:\n                question[0] += 1\n                matches = False\n            if len(count) == 0:\n                continue\n        #---if an expression, compare by the full string because we don't\n        #---know what it is\n        elif kind == \"EXPRESSION\":\n            kind = parseExpression(label[1])\n        elif kind == \"THROW\" and prev is not None and prev == \"TRY\" :\n            kind = \"tryTHROW\"\n        #---a lot of these are IF-BLOCK, which mean one thing, don't re-add\n        elif kind == \"BLOCK\" and prev is not None and prev == \"IF\" :\n            prev = \"BLOCK\"\n            continue\n        #---parsing error, probably part of an expression\n        elif not kind.isalpha():\n            continue\n        #---add to dictionary by statement count\n        #print str(statement_count) +\" v \"+str(statement_N)+ \" k \"+kind\n        if (kind == kind_N or statement_count==0):\n            if(matches is None):\n                question[1] += 1\n                matches = True\n        else:#matches is true\n            matches = False\n        prev = kind #save to keep track of sequenced blocks\n    return question\n\n#parses description of try/catch block into csv components, and then counts\n#the number of instances of each component, eg. RETURN or THROW\ndef countBlocks(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            if statement_count == 0:\n                blocks[0][\"EmptyCatch\"] += 1\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        #---if an expression, parse out kind like printStackTrace\n        elif kind == \"EXPRESSION\":\n            kind = parseExpression(label[1])\n    \t#---TOP level try, nothing before it\n        elif kind == \"TRY\" and prev is None:\n            statement_count = -2\n        elif kind == \"THROW\" and prev is not None and prev == \"TRY\" :\n            kind = \"tryTHROW\"\n        #---a lot of these are IF-BLOCK, which mean one thing, don't re-add\n        elif kind == \"BLOCK\" and prev is not None and prev == \"IF\" :\n            prev = \"BLOCK\"\n            continue\n        #---parsing error, probably part of an expression\n        elif kind != \"END_TRY\" and not kind.isalpha():\n            continue\n        #---add to dictionary by statement count\n        if statement_count not in blocks:\n            blocks[statement_count] = {}\n        if kind in blocks[statement_count]:\n             blocks[statement_count][kind] += 1\n        else:\n             blocks[statement_count][kind] = 1\n        prev = kind #save to keep track of sequenced blocks\n\ndef countTryCatchOnly(results, desc):\n    #results includes end try and end catch for debugging (sanity checking)\n    cs = csv.reader(StringIO.StringIO(desc), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) > 0:\n                results[\"Nested Catch\"] += 1\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            results[\"Catch\"] += 1\n        elif kind == \"END_CATCH\":\n            results[\"Statement Count\"] += statement_count\n            statement_count = count.pop()\n            results[\"End Catch\"] += 1\n        elif kind == \"TRY\":\n            results[\"Try\"] += 1\n        elif kind == \"END_TRY\":\n            results[\"End Try\"] +=1\n    return results\n\n\n\ndef whatDidYouThrow(tDict):\n\tcs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n\tdesc = list(cs)[0]\n\tcount = [] #for nested blocks, we need a stack of statement_count\n\tstatement_count = -1\n\tprev = None\n\tcatchvar = []\n\tfor blk in desc:\n\t\tlabel = [x.strip() for x in blk.split(\":\")]\n\t\tkind = label[0]\n\t\tthrow = None\n\t\t#---count # of statements in each catch block in in CATCH : #N\n\t\tif kind == \"CATCH\":\n\t\t    if len(count) == 0: #not nested\n\t\t        kind = \"TOTAL\" #top level Catch, to distinguish nested\n\t\t    count.append(statement_count+0) #old one in case nested\n\t\t    statement_count = int(label[1])\n\t\t\t#catchvar[]\n\t\tif kind == \"END_CATCH\":\n\t\t    statement_count = count.pop()\n\t\tif kind == \"THROW\":\n\t\t\tif prev != \"TRY\":\n\t\t\t\tthrow = label[1]\n\t\t\t\tif throw == '\\\"NEW':\n\t\t\t\t\tthrow = label[2]\n\t\t\t\telif throw == '\\\"VARACCES':\n\t\t\t\t\tprint \"d\"\n\n\t\t\t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n\t\t#---add to dictionary by statement count\n\t\tif throw is not None:\n\t\t    if statement_count not in blocks:\n\t\t        blocks[statement_count] = {}\n\t\t    if throw in blocks[statement_count]:\n\t\t         blocks[statement_count][throw] += 1\n\t\t    else:\n\t\t         blocks[statement_count][throw] = 1\n\t\tprev = kind #save to keep track of sequenced blocks\n\ndef whatDidYouCatch(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        catch = None\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            tocatch = label[2][1:-1].split(\"|\")\n            catch = []\n            for c in tocatch:\n                catch.append(c)\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        \t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n        #---add to dictionary by statement count\n        if catch is not None:\n            if statement_count not in blocks:\n                blocks[statement_count] = {}\n            for c in catch:\n            \tif c in blocks[statement_count]:\n            \t     blocks[statement_count][c] += 1\n            \telse:\n            \t     blocks[statement_count][c] = 1\n        prev = kind #save to keep track of sequenced blocks\n\ndef whatDidYouCatch(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        catch = None\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            tocatch = label[2][1:-1].split(\"|\")\n            catch = []\n            for c in tocatch:\n                catch.append(c)\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        \t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n        #---add to dictionary by statement count\n        if catch is not None:\n            if statement_count not in blocks:\n                blocks[statement_count] = {}\n            for c in catch:\n            \tif c in blocks[statement_count]:\n            \t     blocks[statement_count][c] += 1\n            \telse:\n            \t     blocks[statement_count][c] = 1\n        prev = kind #save to keep track of sequenced blocks\n\n\ndef parseExpression(desc):\n    c_EXPRESSION[\"TOTAL\"] += 1\n    m = parse(\"{method}({rest}\", desc[\"c_code\"])\n    if(m is None):\n        m = parse(\"{method}.{rest}\", desc[\"c_code\"])\n    if(m is None):\n        m = \"\"\n        #print \"DID NOT PARSE |\"+desc[\"c_code\"]+\"|\"\n    else:\n        methd = m[\"method\"]\n        if methd.find(\"printStackTrace\") != -1:\n            c_EXPRESSION[\"stackTrace\"] += 1\n        elif methd.startswith(\"System.out.println\") or methd.startswith(\"System.err.println\"):\n            c_EXPRESSION[\"println\"] +=1\n        elif methd.find(\"print\") != -1:\n            c_EXPRESSION[\"print(general)\"] +=1\n        elif methd.lower().startswith(\"log\") or methd.lower().find(\".log\") != -1:\n            c_EXPRESSION[\"log\"] +=1\n            #print desc[\"c_code\"]\n        elif methd.lower().startswith(\"assert\"):\n            c_EXPRESSION[\"Assert\"] +=1\n        else:\n            c_EXPRESSION[\"unaccounted\"] += 1\n            lines.append(methd)\n","date":"08/03/2016 10:28am"},{"title":"V1","text":"#sort by: if I have catch blocks of size n + kind, how many catch blocks that are of length N and do kind\n# are there\ndef sortByQuestion(statement_N, kind_N, blk):\n    question = [0,0] #matches, doesn't\n    cs = csv.reader(StringIO.StringIO(blk), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    matches = None\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if (kind == \"TRY\" or kind == \"END_TRY\") and len(count)==0:\n            continue\n        if kind == \"CATCH\":\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            if len(count) == 0: #not nested\n                continue\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n            if not matches:\n                question[0] += 1\n                matches = False\n            if len(count) == 0:\n                continue\n        #---if an expression, compare by the full string because we don't\n        #---know what it is\n        elif kind == \"EXPRESSION\":\n            kind = parseExpression(label[1])\n        elif kind == \"THROW\" and prev is not None and prev == \"TRY\" :\n            kind = \"tryTHROW\"\n        #---a lot of these are IF-BLOCK, which mean one thing, don't re-add\n        elif kind == \"BLOCK\" and prev is not None and prev == \"IF\" :\n            prev = \"BLOCK\"\n            continue\n        #---parsing error, probably part of an expression\n        elif not kind.isalpha():\n            continue\n        #---add to dictionary by statement count\n        #print str(statement_count) +\" v \"+str(statement_N)+ \" k \"+kind\n        if (kind == kind_N or statement_count==0):\n            if(matches is None):\n                question[1] += 1\n                matches = True\n        else:#matches is true\n            matches = False\n        prev = kind #save to keep track of sequenced blocks\n    return question\n\n#parses description of try/catch block into csv components, and then counts\n#the number of instances of each component, eg. RETURN or THROW\ndef countBlocks(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            if statement_count == 0:\n                blocks[0][\"EmptyCatch\"] += 1\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        #---if an expression, parse out kind like printStackTrace\n        elif kind == \"EXPRESSION\":\n            kind = parseExpression(label[1])\n    \t#---TOP level try, nothing before it\n        elif kind == \"TRY\" and prev is None:\n            statement_count = -2\n        elif kind == \"THROW\" and prev is not None and prev == \"TRY\" :\n            kind = \"tryTHROW\"\n        #---a lot of these are IF-BLOCK, which mean one thing, don't re-add\n        elif kind == \"BLOCK\" and prev is not None and prev == \"IF\" :\n            prev = \"BLOCK\"\n            continue\n        #---parsing error, probably part of an expression\n        elif kind != \"END_TRY\" and not kind.isalpha():\n            continue\n        #---add to dictionary by statement count\n        if statement_count not in blocks:\n            blocks[statement_count] = {}\n        if kind in blocks[statement_count]:\n             blocks[statement_count][kind] += 1\n        else:\n             blocks[statement_count][kind] = 1\n        prev = kind #save to keep track of sequenced blocks\n\ndef countTryCatchOnly(results, desc):\n    #results includes end try and end catch for debugging (sanity checking)\n    cs = csv.reader(StringIO.StringIO(desc), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) > 0:\n                results[\"Nested Catch\"] += 1\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            results[\"Catch\"] += 1\n        elif kind == \"END_CATCH\":\n            results[\"Statement Count\"] += statement_count\n            statement_count = count.pop()\n            results[\"End Catch\"] += 1\n        elif kind == \"TRY\":\n            results[\"Try\"] += 1\n        elif kind == \"END_TRY\":\n            results[\"End Try\"] +=1\n    return results\n\n\n\ndef whatDidYouThrow(tDict):\n\tcs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n\tdesc = list(cs)[0]\n\tcount = [] #for nested blocks, we need a stack of statement_count\n\tstatement_count = -1\n\tprev = None\n\tcatchvar = []\n\tfor blk in desc:\n\t\tlabel = [x.strip() for x in blk.split(\":\")]\n\t\tkind = label[0]\n\t\tthrow = None\n\t\t#---count # of statements in each catch block in in CATCH : #N\n\t\tif kind == \"CATCH\":\n\t\t    if len(count) == 0: #not nested\n\t\t        kind = \"TOTAL\" #top level Catch, to distinguish nested\n\t\t    count.append(statement_count+0) #old one in case nested\n\t\t    statement_count = int(label[1])\n\t\t\t#catchvar[]\n\t\tif kind == \"END_CATCH\":\n\t\t    statement_count = count.pop()\n\t\tif kind == \"THROW\":\n\t\t\tif prev != \"TRY\":\n\t\t\t\tthrow = label[1]\n\t\t\t\tif throw == '\\\"NEW':\n\t\t\t\t\tthrow = label[2]\n\t\t\t\telif throw == '\\\"VARACCES':\n\t\t\t\t\tprint \"d\"\n\n\t\t\t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n\t\t#---add to dictionary by statement count\n\t\tif throw is not None:\n\t\t    if statement_count not in blocks:\n\t\t        blocks[statement_count] = {}\n\t\t    if throw in blocks[statement_count]:\n\t\t         blocks[statement_count][throw] += 1\n\t\t    else:\n\t\t         blocks[statement_count][throw] = 1\n\t\tprev = kind #save to keep track of sequenced blocks\n\ndef whatDidYouCatch(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        catch = None\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            tocatch = label[2][1:-1].split(\"|\")\n            catch = []\n            for c in tocatch:\n                catch.append(c)\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        \t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n        #---add to dictionary by statement count\n        if catch is not None:\n            if statement_count not in blocks:\n                blocks[statement_count] = {}\n            for c in catch:\n            \tif c in blocks[statement_count]:\n            \t     blocks[statement_count][c] += 1\n            \telse:\n            \t     blocks[statement_count][c] = 1\n        prev = kind #save to keep track of sequenced blocks\n\ndef whatDidYouCatch(tDict):\n    cs = csv.reader(StringIO.StringIO(tDict[\"desc\"]), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        catch = None\n        #---count # of statements in each catch block in in CATCH : #N\n        if kind == \"CATCH\":\n            if len(count) == 0: #not nested\n                kind = \"TOTAL\" #top level Catch, to distinguish nested\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n            tocatch = label[2][1:-1].split(\"|\")\n            catch = []\n            for c in tocatch:\n                catch.append(c)\n        if kind == \"END_CATCH\":\n            statement_count = count.pop()\n        \t\t#print \"THROW is  \"+throw + \"| \"+str(label) +\"  | \"+label[2]\n        #---add to dictionary by statement count\n        if catch is not None:\n            if statement_count not in blocks:\n                blocks[statement_count] = {}\n            for c in catch:\n            \tif c in blocks[statement_count]:\n            \t     blocks[statement_count][c] += 1\n            \telse:\n            \t     blocks[statement_count][c] = 1\n        prev = kind #save to keep track of sequenced blocks\n\n\ndef parseExpression(desc):\n    c_EXPRESSION[\"TOTAL\"] += 1\n    m = parse(\"{method}({rest}\", desc[\"c_code\"])\n    if(m is None):\n        m = parse(\"{method}.{rest}\", desc[\"c_code\"])\n    if(m is None):\n        m = \"\"\n        #print \"DID NOT PARSE |\"+desc[\"c_code\"]+\"|\"\n    else:\n        methd = m[\"method\"]\n        if methd.find(\"printStackTrace\") != -1:\n            c_EXPRESSION[\"stackTrace\"] += 1\n        elif methd.startswith(\"System.out.println\") or methd.startswith(\"System.err.println\"):\n            c_EXPRESSION[\"println\"] +=1\n        elif methd.find(\"print\") != -1:\n            c_EXPRESSION[\"print(general)\"] +=1\n        elif methd.lower().startswith(\"log\") or methd.lower().find(\".log\") != -1:\n            c_EXPRESSION[\"log\"] +=1\n            #print desc[\"c_code\"]\n        elif methd.lower().startswith(\"assert\"):\n            c_EXPRESSION[\"Assert\"] +=1\n        else:\n            c_EXPRESSION[\"unaccounted\"] += 1\n            lines.append(methd)\n","date":"08/03/2016 10:29am"}]}},{"variants":{"currentVersion":{"title":"Count returns, throwsʔ","text":"lines = []\nc_RETURN = {\"TOTAL\" : 0, \"LITERAL\" : 0, \"NOTHING\" : 0, \"OTHER\" : 0}\nc_THROW = {\"TOTAL\" : 0}\nunaccounted = 0\ntotal_lines = 0\nc_EXPRESSION = {\"TOTAL\" : 0, \"stackTrace\" : 0, \"print(general)\": 0, \"println\" : 0, \"log\" : 0, \"Assert\" : 0, \"unaccounted\" : 0}\n\ndef parseReturn(desc):\n    c_RETURN[\"TOTAL\"] += 1\n    if desc[\"c_code\"] == \"\\n\":\n        c_RETURN[\"NOTHING\"] += 1\n    else:\n        ret = parse(\"{ret_type}: {ret_value}\",desc[\"c_code\"])\n        #print ret\n        if(ret is None):\n            return\n            #print \"DID NOT PARSE |\"+desc[\"c_code\"]+\"|\"\n        elif(ret[\"ret_type\"] == \"LITERAL\"):\n            c_RETURN[\"LITERAL\"] += 1\n        else:\n            c_RETURN[\"OTHER\"] += 1\n\ndef parseThrow(desc):\n    c_THROW[\"TOTAL\"] +=1\n\nwith open(inFile,'r') as f:\n    for line in f:\n        total_lines += 1\n        c = parse(\"CatchDesc[{c_type}][{lines_num}] = {c_type2}: {c_code}\", line)\n        if c is None:\n            c = parse(\"CatchDesc[{c_type}] = \", line)\n        if c is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            desc = c.named\n            if(desc[\"c_type\"] == \"RETURN\"):\n                parseReturn(desc)\n            elif(desc[\"c_type\"] == \"THROW\"):\n                parseThrow(desc)\n            elif(desc[\"c_type\"] == \"EXPRESSION\"):\n                parseExpression(desc)\n            else:\n                unaccounted += 1\n\n\nprint \"Total lines: \"+str(total_lines)\nprint \"Expression \" + str(c_EXPRESSION)\nprint \"Return \" + str(c_RETURN)\nprint \"Throw \" + str(c_THROW)\nprint unaccounted + c_EXPRESSION[\"unaccounted\"]\n\n\n        # spl = line.split(\"=\")\n        # if len(spl)<2:\n        #     continue\n        # s_type = spl[0].split(\"[\",\"]\")\n        # lines.append(float(num))\n\n#print lines\nwith open(outFile, 'w') as outfile:\n    for l in lines:\n        outfile.write(\"{}\\n\".format(l))\n","date":"08/03/2016 10:28am"},"versions":[{"title":"Count returns, throwsʔ","text":"lines = []\nc_RETURN = {\"TOTAL\" : 0, \"LITERAL\" : 0, \"NOTHING\" : 0, \"OTHER\" : 0}\nc_THROW = {\"TOTAL\" : 0}\nunaccounted = 0\ntotal_lines = 0\nc_EXPRESSION = {\"TOTAL\" : 0, \"stackTrace\" : 0, \"print(general)\": 0, \"println\" : 0, \"log\" : 0, \"Assert\" : 0, \"unaccounted\" : 0}\n\ndef parseReturn(desc):\n    c_RETURN[\"TOTAL\"] += 1\n    if desc[\"c_code\"] == \"\\n\":\n        c_RETURN[\"NOTHING\"] += 1\n    else:\n        ret = parse(\"{ret_type}: {ret_value}\",desc[\"c_code\"])\n        #print ret\n        if(ret is None):\n            return\n            #print \"DID NOT PARSE |\"+desc[\"c_code\"]+\"|\"\n        elif(ret[\"ret_type\"] == \"LITERAL\"):\n            c_RETURN[\"LITERAL\"] += 1\n        else:\n            c_RETURN[\"OTHER\"] += 1\n\ndef parseThrow(desc):\n    c_THROW[\"TOTAL\"] +=1\n\nwith open(inFile,'r') as f:\n    for line in f:\n        total_lines += 1\n        c = parse(\"CatchDesc[{c_type}][{lines_num}] = {c_type2}: {c_code}\", line)\n        if c is None:\n            c = parse(\"CatchDesc[{c_type}] = \", line)\n        if c is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            desc = c.named\n            if(desc[\"c_type\"] == \"RETURN\"):\n                parseReturn(desc)\n            elif(desc[\"c_type\"] == \"THROW\"):\n                parseThrow(desc)\n            elif(desc[\"c_type\"] == \"EXPRESSION\"):\n                parseExpression(desc)\n            else:\n                unaccounted += 1\n\n\nprint \"Total lines: \"+str(total_lines)\nprint \"Expression \" + str(c_EXPRESSION)\nprint \"Return \" + str(c_RETURN)\nprint \"Throw \" + str(c_THROW)\nprint unaccounted + c_EXPRESSION[\"unaccounted\"]\n\n\n        # spl = line.split(\"=\")\n        # if len(spl)<2:\n        #     continue\n        # s_type = spl[0].split(\"[\",\"]\")\n        # lines.append(float(num))\n\n#print lines\nwith open(outFile, 'w') as outfile:\n    for l in lines:\n        outfile.write(\"{}\\n\".format(l))\n","date":"08/03/2016 10:28am"}]}},{"variants":{"currentVersion":{"title":"Count throwsʔ","text":"header = []\n\ntestc = 0 #debug only\n#----similarity scores by matching\nsim_file = []\nsim_diff = []\nsim_project = []\n\n\nproj_Q = {}\ntestCount = 0\nfileCount = 0\ntrycatchcountTotal = {}\nwith open(inFile,'r') as f:\n    prev = {} #line that came before\n    currentFile = None\n    for line in f:\n        #if testc > 1000000:\n        #      break;\n        testc += 1\n        total_lines += 1\n        tc = parse(\"CatchDesc[{project}][{file}] = {desc}\", line)\n        if tc is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            tcDict = tc.named\n            if \"test\" not in tcDict[\"file\"].lower():\n                if tcDict[\"project\"] not in grouping:\n                    grouping[tcDict[\"project\"]] = {}\n                    currrent_count = {\"File Count\":0,\"Try\":0, \"Catch\":0, \"Statement Count\":0,\"Nested Try\":0, \"Nested Catch\":0, \"End Try\": 0, \"End Catch\":0}\n                else:\n                    currrent_count = grouping[tcDict[\"project\"]]\n                #if tcDict[\"file\"] not in grouping:\n                #    grouping[tcDict[\"project\"]][tcDict[\"file\"]] = {}\n                #    currrent_count = {\"Try\":0, \"Catch\":0, \"Statement Count\":0, \"Nested Try\":0, \"Nested Catch\":0, \"End Try\": 0, \"End Catch\":0}\n                currrent_count[\"File Count\"] += 1\n                grouping[tcDict[\"project\"]] = countTryCatchOnly(currrent_count, tcDict[\"desc\"])\n\nprint grouping\n#simba = []\n#sampleUnrelatedBlocks(simba)\n#sampleWithinProjects(simba)#calcSimByBlockLength_diffProj()\n#print str(total_lines) + \" total lines\"\n#print proj_Q\n#print blocks\n\nwith open(outFile, \"w\") as outfile:\n    outfile.write(\"project, file count, Try, Catch, Statement Count, Nested Try, Nested Catch \\n\")\n    for proj in grouping:\n        statement_mean = 0\n        if grouping[proj][\"Catch\"] >0:\n            statement_mean= (float(grouping[proj][\"Statement Count\"]))/(float (grouping[proj][\"Catch\"]))\n        outfile.write(proj +\",\" + str(grouping[proj][\"File Count\"]) + \",\" + str(grouping[proj][\"Try\"]) + \",\" + str(grouping[proj][\"Catch\"]) + \",\" + str(statement_mean)+ \",\"\n                        + str(grouping[proj][\"Nested Try\"]) + \",\" + str(grouping[proj][\"Nested Catch\"]) + \"\\n\")\n","date":"08/03/2016 10:28am"},"versions":[{"title":"Count throwsʔ","text":"header = []\n\ntestc = 0 #debug only\n#----similarity scores by matching\nsim_file = []\nsim_diff = []\nsim_project = []\n\n\nproj_Q = {}\ntestCount = 0\nfileCount = 0\ntrycatchcountTotal = {}\nwith open(inFile,'r') as f:\n    prev = {} #line that came before\n    currentFile = None\n    for line in f:\n        #if testc > 1000000:\n        #      break;\n        testc += 1\n        total_lines += 1\n        tc = parse(\"CatchDesc[{project}][{file}] = {desc}\", line)\n        if tc is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            tcDict = tc.named\n            if \"test\" not in tcDict[\"file\"].lower():\n                if tcDict[\"project\"] not in grouping:\n                    grouping[tcDict[\"project\"]] = {}\n                    currrent_count = {\"File Count\":0,\"Try\":0, \"Catch\":0, \"Statement Count\":0,\"Nested Try\":0, \"Nested Catch\":0, \"End Try\": 0, \"End Catch\":0}\n                else:\n                    currrent_count = grouping[tcDict[\"project\"]]\n                #if tcDict[\"file\"] not in grouping:\n                #    grouping[tcDict[\"project\"]][tcDict[\"file\"]] = {}\n                #    currrent_count = {\"Try\":0, \"Catch\":0, \"Statement Count\":0, \"Nested Try\":0, \"Nested Catch\":0, \"End Try\": 0, \"End Catch\":0}\n                currrent_count[\"File Count\"] += 1\n                grouping[tcDict[\"project\"]] = countTryCatchOnly(currrent_count, tcDict[\"desc\"])\n\nprint grouping\n#simba = []\n#sampleUnrelatedBlocks(simba)\n#sampleWithinProjects(simba)#calcSimByBlockLength_diffProj()\n#print str(total_lines) + \" total lines\"\n#print proj_Q\n#print blocks\n\nwith open(outFile, \"w\") as outfile:\n    outfile.write(\"project, file count, Try, Catch, Statement Count, Nested Try, Nested Catch \\n\")\n    for proj in grouping:\n        statement_mean = 0\n        if grouping[proj][\"Catch\"] >0:\n            statement_mean= (float(grouping[proj][\"Statement Count\"]))/(float (grouping[proj][\"Catch\"]))\n        outfile.write(proj +\",\" + str(grouping[proj][\"File Count\"]) + \",\" + str(grouping[proj][\"Try\"]) + \",\" + str(grouping[proj][\"Catch\"]) + \",\" + str(statement_mean)+ \",\"\n                        + str(grouping[proj][\"Nested Try\"]) + \",\" + str(grouping[proj][\"Nested Catch\"]) + \"\\n\")\n","date":"08/03/2016 10:28am"}]}},{"variants":{"currentVersion":{"title":"Count returnsʔ","text":"\n#parses description of try/catch block into csv components, and then counts\n#the number of instances of each component, eg. RETURN or THROW\ndef countReturnsOnly(returns, tDict):\n    cs = csv.reader(StringIO.StringIO(tDict), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        if kind == \"CATCH\":\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n        elif kind == \"END_CATCH\":\n            statement_count = count.pop()\n        elif kind == \"RETURN\":\n            ret = label[1]\n            if(ret == \"\\\"LITERAL\"):\n                ret = label[2]\n                if(ret.startswith(\"\\\"\")):\n                    ret = \"String\"\n                else:\n                    try:\n                        ret = ret.strip('\"')\n                        #print ret\n                        f = int(ret)\n                        ret = \"Number\"\n                    except:\n                        ret = ret.strip('\"')\n                        if ret.lower() == \"false\":\n                            ret = \"false\"\n                        elif ret.lower() == \"true\":\n                            ret = \"true\"\n                        elif ret == \"null\":\n                            ret = \"null\"\n                        else:\n                            ret = \"OTHER\"\n\n            elif ret == '\"\"':\n                ret = \"return\"\n            else:\n                ret = \"OTHER\"\n            num = \"1\"\n            if statement_count > 1:\n                num = \">1\"\n            if num not in returns:\n                returns[num] = {}\n            if ret not in returns[num]:\n                returns[num][ret] = 1\n            else:\n                 returns[num][ret] += 1\n    return returns\n\n\n\nproj_Q = {}\ntestCount = 0\nfileCount = 0\ntrycatchcountTotal = {}\ncountReturns = {}\nwith open(inFile,'r') as f:\n    prev = {} #line that came before\n    currentFile = None\n    for line in f:\n        #if testc > 1000000:\n        #      break;\n        #testc += 1\n        total_lines += 1\n        tc = parse(\"CatchDesc[{project}][{file}] = {desc}\", line)\n        if tc is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            tcDict = tc.named\n            if \"test\" not in tcDict[\"file\"].lower():\n                countReturnsOnly(countReturns, tcDict[\"desc\"])\n\nprint countReturns\n\nwith open(outFile, 'w') as outfile:\n    for ret in countReturns:\n        outfile.write(ret +\",\"+str(countReturns[ret])+\"\\n\")\n","date":"08/03/2016 10:28am"},"versions":[{"title":"Count returnsʔ","text":"\n#parses description of try/catch block into csv components, and then counts\n#the number of instances of each component, eg. RETURN or THROW\ndef countReturnsOnly(returns, tDict):\n    cs = csv.reader(StringIO.StringIO(tDict), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        if kind == \"CATCH\":\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n        elif kind == \"END_CATCH\":\n            statement_count = count.pop()\n        elif kind == \"RETURN\":\n            ret = label[1]\n            if(ret == \"\\\"LITERAL\"):\n                ret = label[2]\n                if(ret.startswith(\"\\\"\")):\n                    ret = \"String\"\n                else:\n                    try:\n                        ret = ret.strip('\"')\n                        #print ret\n                        f = int(ret)\n                        ret = \"Number\"\n                    except:\n                        ret = ret.strip('\"')\n                        if ret.lower() == \"false\":\n                            ret = \"false\"\n                        elif ret.lower() == \"true\":\n                            ret = \"true\"\n                        elif ret == \"null\":\n                            ret = \"null\"\n                        else:\n                            ret = \"OTHER\"\n\n            elif ret == '\"\"':\n                ret = \"return\"\n            else:\n                ret = \"OTHER\"\n            num = \"1\"\n            if statement_count > 1:\n                num = \">1\"\n            if num not in returns:\n                returns[num] = {}\n            if ret not in returns[num]:\n                returns[num][ret] = 1\n            else:\n                 returns[num][ret] += 1\n    return returns\n\n\n\nproj_Q = {}\ntestCount = 0\nfileCount = 0\ntrycatchcountTotal = {}\ncountReturns = {}\nwith open(inFile,'r') as f:\n    prev = {} #line that came before\n    currentFile = None\n    for line in f:\n        #if testc > 1000000:\n        #      break;\n        #testc += 1\n        total_lines += 1\n        tc = parse(\"CatchDesc[{project}][{file}] = {desc}\", line)\n        if tc is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            tcDict = tc.named\n            if \"test\" not in tcDict[\"file\"].lower():\n                countReturnsOnly(countReturns, tcDict[\"desc\"])\n\nprint countReturns\n\nwith open(outFile, 'w') as outfile:\n    for ret in countReturns:\n        outfile.write(ret +\",\"+str(countReturns[ret])+\"\\n\")\n","date":"08/03/2016 10:28am"}]}}]}}