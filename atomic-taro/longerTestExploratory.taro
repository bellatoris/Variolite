{"atomicTaroViewState":{"sourceFile":true,"segments":{"header":{"title":""},"segments":[{"title":"Shared Functions"},{"currentVariant":{"title":"Count returns, throws"},"variants":{"title":"Count returns, throws","text":"\nlines = []\nc_RETURN = {\"TOTAL\" : 0, \"LITERAL\" : 0, \"NOTHING\" : 0, \"OTHER\" : 0}\nc_THROW = {\"TOTAL\" : 0}\nunaccounted = 0\ntotal_lines = 0\nc_EXPRESSION = {\"TOTAL\" : 0, \"stackTrace\" : 0, \"print(general)\": 0, \"println\" : 0, \"log\" : 0, \"Assert\" : 0, \"unaccounted\" : 0}\n\ndef parseReturn(desc):\n    c_RETURN[\"TOTAL\"] += 1\n    if desc[\"c_code\"] == \"\\n\":\n        c_RETURN[\"NOTHING\"] += 1\n    else:\n        ret = parse(\"{ret_type}: {ret_value}\",desc[\"c_code\"])\n        #print ret\n        if(ret is None):\n            return\n            #print \"DID NOT PARSE |\"+desc[\"c_code\"]+\"|\"\n        elif(ret[\"ret_type\"] == \"LITERAL\"):\n            c_RETURN[\"LITERAL\"] += 1\n        else:\n            c_RETURN[\"OTHER\"] += 1\n\ndef parseThrow(desc):\n    c_THROW[\"TOTAL\"] +=1\n\nwith open(inFile,'r') as f:\n    for line in f:\n        total_lines += 1\n        c = parse(\"CatchDesc[{c_type}][{lines_num}] = {c_type2}: {c_code}\", line)\n        if c is None:\n            c = parse(\"CatchDesc[{c_type}] = \", line)\n        if c is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            desc = c.named\n            if(desc[\"c_type\"] == \"RETURN\"):\n                parseReturn(desc)\n            elif(desc[\"c_type\"] == \"THROW\"):\n                parseThrow(desc)\n            elif(desc[\"c_type\"] == \"EXPRESSION\"):\n                parseExpression(desc)\n            else:\n                unaccounted += 1\n\n\nprint \"Total lines: \"+str(total_lines)\nprint \"Expression \" + str(c_EXPRESSION)\nprint \"Return \" + str(c_RETURN)\nprint \"Throw \" + str(c_THROW)\nprint unaccounted + c_EXPRESSION[\"unaccounted\"]\n\n\n        # spl = line.split(\"=\")\n        # if len(spl)<2:\n        #     continue\n        # s_type = spl[0].split(\"[\",\"]\")\n        # lines.append(float(num))\n\n#print lines\nwith open(outFile, 'w') as outfile:\n    for l in lines:\n        outfile.write(\"{}\\n\".format(l))\n","children":null}},{"currentVariant":{"title":"Count throws"},"variants":{"title":"Count throws","text":"\nheader = []\n\ntestc = 0 #debug only\n#----similarity scores by matching\nsim_file = []\nsim_diff = []\nsim_project = []\n\n\nproj_Q = {}\ntestCount = 0\nfileCount = 0\ntrycatchcountTotal = {}\nwith open(inFile,'r') as f:\n    prev = {} #line that came before\n    currentFile = None\n    for line in f:\n        #if testc > 1000000:\n        #      break;\n        testc += 1\n        total_lines += 1\n        tc = parse(\"CatchDesc[{project}][{file}] = {desc}\", line)\n        if tc is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            tcDict = tc.named\n            if \"test\" not in tcDict[\"file\"].lower():\n                if tcDict[\"project\"] not in grouping:\n                    grouping[tcDict[\"project\"]] = {}\n                    currrent_count = {\"File Count\":0,\"Try\":0, \"Catch\":0, \"Statement Count\":0,\"Nested Try\":0, \"Nested Catch\":0, \"End Try\": 0, \"End Catch\":0}\n                else:\n                    currrent_count = grouping[tcDict[\"project\"]]\n                #if tcDict[\"file\"] not in grouping:\n                #    grouping[tcDict[\"project\"]][tcDict[\"file\"]] = {}\n                #    currrent_count = {\"Try\":0, \"Catch\":0, \"Statement Count\":0, \"Nested Try\":0, \"Nested Catch\":0, \"End Try\": 0, \"End Catch\":0}\n                currrent_count[\"File Count\"] += 1\n                grouping[tcDict[\"project\"]] = countTryCatchOnly(currrent_count, tcDict[\"desc\"])\n\nprint grouping\n#simba = []\n#sampleUnrelatedBlocks(simba)\n#sampleWithinProjects(simba)#calcSimByBlockLength_diffProj()\n#print str(total_lines) + \" total lines\"\n#print proj_Q\n#print blocks\n\nwith open(outFile, \"w\") as outfile:\n    outfile.write(\"project, file count, Try, Catch, Statement Count, Nested Try, Nested Catch \\n\")\n    for proj in grouping:\n        statement_mean = 0\n        if grouping[proj][\"Catch\"] >0:\n            statement_mean= (float(grouping[proj][\"Statement Count\"]))/(float (grouping[proj][\"Catch\"]))\n        outfile.write(proj +\",\" + str(grouping[proj][\"File Count\"]) + \",\" + str(grouping[proj][\"Try\"]) + \",\" + str(grouping[proj][\"Catch\"]) + \",\" + str(statement_mean)+ \",\"\n                        + str(grouping[proj][\"Nested Try\"]) + \",\" + str(grouping[proj][\"Nested Catch\"]) + \"\\n\")\n","children":null}},{"currentVariant":{"title":"Count returns"},"variants":{"title":"Count returns","text":"\n\n#parses description of try/catch block into csv components, and then counts\n#the number of instances of each component, eg. RETURN or THROW\ndef countReturnsOnly(returns, tDict):\n    cs = csv.reader(StringIO.StringIO(tDict), delimiter='|', quotechar='\"')\n    desc = list(cs)[0]\n    count = [] #for nested blocks, we need a stack of statement_count\n    statement_count = -1\n    prev = None\n    for blk in desc:\n        label = [x.strip() for x in blk.split(\":\")]\n        kind = label[0]\n        if kind == \"CATCH\":\n            count.append(statement_count+0) #old one in case nested\n            statement_count = int(label[1])\n        elif kind == \"END_CATCH\":\n            statement_count = count.pop()\n        elif kind == \"RETURN\":\n            ret = label[1]\n            if(ret == \"\\\"LITERAL\"):\n                ret = label[2]\n                if(ret.startswith(\"\\\"\")):\n                    ret = \"String\"\n                else:\n                    try:\n                        ret = ret.strip('\"')\n                        #print ret\n                        f = int(ret)\n                        ret = \"Number\"\n                    except:\n                        ret = ret.strip('\"')\n                        if ret.lower() == \"false\":\n                            ret = \"false\"\n                        elif ret.lower() == \"true\":\n                            ret = \"true\"\n                        elif ret == \"null\":\n                            ret = \"null\"\n                        else:\n                            ret = \"OTHER\"\n\n            elif ret == '\"\"':\n                ret = \"return\"\n            else:\n                ret = \"OTHER\"\n            num = \"1\"\n            if statement_count > 1:\n                num = \">1\"\n            if num not in returns:\n                returns[num] = {}\n            if ret not in returns[num]:\n                returns[num][ret] = 1\n            else:\n                 returns[num][ret] += 1\n    return returns\n\n\n\nproj_Q = {}\ntestCount = 0\nfileCount = 0\ntrycatchcountTotal = {}\ncountReturns = {}\nwith open(inFile,'r') as f:\n    prev = {} #line that came before\n    currentFile = None\n    for line in f:\n        #if testc > 1000000:\n        #      break;\n        #testc += 1\n        total_lines += 1\n        tc = parse(\"CatchDesc[{project}][{file}] = {desc}\", line)\n        if tc is None:\n            print \"DID NOT PARSE \"+line\n        else:\n            tcDict = tc.named\n            if \"test\" not in tcDict[\"file\"].lower():\n                countReturnsOnly(countReturns, tcDict[\"desc\"])\n\nprint countReturns\n\nwith open(outFile, 'w') as outfile:\n    for ret in countReturns:\n        outfile.write(ret +\",\"+str(countReturns[ret])+\"\\n\")\n","children":null}}]}}}